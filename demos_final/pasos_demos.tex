\documentclass[12pt,a4paper]{article}
\input{packages.tex}
\author{Mansilla, Kevin Gaston\footnote{\href{mailto:kevingston47@gmail.com}{kevingston47@gmail.com}}}
\title{Discreta II: Pasos para las demos}
\date{\today}
\begin{document}
\maketitle{}

%%%%%% 1 %%%%%%
\begin{itemize}
    \item [1)] \textbf{Cual es la complejidad del algoritmo de Edmonds-Karp? Probarlo (
        Nota: en la prueba se definen unas distancias, y se prueba que esas 
        distancias no disminuyen en pasos sucesivos de EK. Ud. puede usar esto 
        sin necesidad de probarlo.)}
        \label{dem:EK}
\end{itemize}
\begin{itemize}
    \item [1)] Un lado se vuelve crítico al pasar de $f_{k}$ a $f_{k+1}$ si se 
        satura o vacia. Definir el paso $k$ y $j$ para un vertice $z$
    \item [2)] Analizar $\overleftarrow{xz} \in E$, $\exists l: k\< l \< j$
        ver caso backward y fordward para $l$.
    \item [3)] Entonces la conclución para $k$. $d_{k}(z) = d_{k}(x) + 1$ (fordward)
        y $d_{k}(x) = d_{k}(z) + 1$ (backward).
    \item [4)] Usar todo lo anterior para llegar a $d_{l}(t) = d_{k}(t) + 2$
        que es la conclusión de la pruba, es que una vez que un lado se vuelve 
        crítico solo puede volver a ser crítico si la distancia entre $s$ y $t$
        aumenta en por lo menos $2$. que es $\frac{n-1}{2}$ veces.
    \item [5)] Resumen de la prueba. hay $m$ lados odnde cada lado se vuelve 
        critico $O(n)$ veces por lo que es $O(mn)$ más la complejidad de $BFS$
        que es $O(m)$ por lo que la complejidad es $O(m^{2}n)$.
\end{itemize}

%%%%%% 2 %%%%%%
\begin{itemize}
    \item [2)] \textbf{Probar que si, dados vértices $x$, $z$ y flujo $f$ definimos a la distancia 
    entre $x$ y $z$ relativa a $f$ como la longitud del menor $f-$camino aumentante 
    entre $x$ y $z$, si es que existe tal camino, o infinito si no existe o 0 
    si $x = z$, denotandola por $d_{f} (x, z)$, y definimos 
    $d_{k}(x) = d_{f_{k}} (s, x)$, donde $f_{k}$ es el $k-$ésimo flujo en una 
    corrida de Edmonds-Karp, entonces $d_{k}(x) \< d_{k+1}(x)$}
    \label{dem:dist}
\end{itemize}
\begin{itemize}
    \item [1)] Definir $A = \llaves{y:d_{k+1}(y) < d_{k}(y)}$ y tratar de probar que 
        $A = \emptyset$ por absurdo.
    \item [2)] Tomar un elemento $x \in A$ tal que $d_{k+1}(x) \< d_{k+1}(y)\,\, \forall y \in A$.
        entonces en $x$ se cumple lo mismo que en $y$. Y fundamental es tomar un 
        $f_{k+1}-$ca entre $s$ y $x$ de menor longitud (EK).
    \item [3)] Sea $z$ el vertice inmediatamente anterior a $x$ como el camino es de 
        longitud minima $d_{k+1}(x) = d_{k+1}(z) +1$.
    \item [4)] Como $z \notin A$ se da lo opuesto que en $A$. Ademas existe un $f_{k}-$
        camino aumentante entre $s$ y $z$ y tomamos el de longitud minima (EK).
    \item [5)] Primero analizamos el camino $s\ldots \overleftarrow{xz} \ldots t$ 
        y hay que llegar a $0 < 2$.
    \item [6)] Analizar caso fordward del $f_{k}-$ca y se llega a $0<0$
    \item [7)] Conclusiones de la prueba
\end{itemize}

%%%%%% 3 %%%%%%
\begin{itemize}
    \item [3)] \textbf{Cual es la complejidad del algoritmo de Dinic? Probarla en ambas 
    versiones: Dinitz original y Dinic-Even. (no hace falta probar que la distancia 
    en networks auxiliares sucesivos aumenta)}
    \label{dem:Dinic}
\end{itemize}
\begin{itemize}
    \item [1)] \textbf{Dinitz original}
    \begin{itemize}
        \item [a)] Definir el colorario de complejidad de hallar un FB.
        \item [b)] Definir que la complejidad de hallar un FB es $O(mn)$.
        \item [c)] Depurar en el primer NA, como hay $r$ niveles es $O(n)$.
        \item [d)] Cada camino satura al menos un lado $O(m)$ caminos.
        \item [e)] Hallar la complejidad de todos los podar.
        \item [f)] Primero revisar los vertices es $O(1)$ pero como hay $n$ 
            vertices es $O(n)$.
        \item [g)] Borrar lados, no queremos la de un podar sino la de todos, 
            pues un podar puede ser muy grande y va redciendo a medida que se 
            borran lados. Entonces es $O(m)$.
        \item [h)] Conclusión de la prueba.
    \end{itemize}
    \item [2)] \textbf{Dinic-Even}
        \begin{itemize}
            \item [a)] La complejidad se halla usando el corolario de complejidad 
                de hallar un FB.
            \item [b)] La complejidad de hallar un FB es $O(mn)$.
            \item [c)] Una corrida es una palabra que se obtiene con DFS (dar ejemplo).
            \item [d)] Definir $AVANZAR$, $RETROCEDER$ y $INCREMENTAR\_E\_INICIALIZAR$.
                y dar complejidades.
            \item [e)] Calcular la complejidad de una palabra $A\ldots AX$ es $O(m)$.
            \item [f)] Calcular cuantas palabras hay, es $O(n)$.
            \item [g)] Conclusión
        \end{itemize}
\end{itemize}

%%%%%% 4 %%%%%%
\begin{itemize}
    \item [4)] \textbf{Cual es la complejidad del algoritmo de Wave? Probarla. (no hace falta 
    probar que la distancia en networks auxiliares sucesivos aumenta).}
    \label{dem:Wave}
\end{itemize}
\begin{itemize}
    \item [1)] Corolario de flujos bloqueantes.
    \item [2)] Definir los fwb, bwb y cantidad de olas $O(n)$.
    \item [3)] Calcular la complejidad de los fwb dividiendolo en dos partes
        primero $S$ que es la complejidad total de los fwb saturado y $P$ que 
        es la complejidad parcial de fwb.
    \item [4)] Los mismo para los bwb con $V$ para los bwb vacios y $Q$ para 
        los bwb parciales.
    \item [5)] Conclución $S + P + V + Q = O(n^{2})$.
\end{itemize}

%%%%%% 5 %%%%%%
\begin{itemize}
    \item [5)] \textbf{Probar que la distancia en networks auxiliares sucesivos aumenta.}
    \label{dem:dist2}
\end{itemize}
\begin{itemize}
    \item [1)] Definir NA, NA', $d$ y $d'$ para probar que $d(t) < d'(t)$.
    \item [2)] Suponemos $d'(t) < \infty$ por lo que existe al menos un camino 
        aumentante, entre $s$ y $t$ en el network original, por lo tanto existe 
        un camino dirigido de $s$ a $t$ en el NA'.
    \item [3)] Sea $s=x_{0},x_{1},\ldots ,x_{n} =t$ un camino dirigido en NA'. Como
        NA' es por niveles entonces $d(x_{i}) = i$. Lo más importante es que ese 
        camno no puede estar en NA, porque para pasar de NA a NA' se bloquean todos 
        los caminos de NA por lo tanto si ese camino estuviera en NA se hubiera 
        bloqueado y no estaría en NA' sino es camino en NA entonces puede suceder:
        Falta un vertice o Falta un lado.
    \item [4)] Analizar le caso en que falte un vertice. tomar un $x$ cualquiera por 
        lo que $x_{i} \notin NA$ entonces $d(t) \< d(x_{i})$, esar EK.
    \item Analizar el caso en que falte un lado, tiene dos casos.
    \item [5)] Caso 1, $d(x_{i+1}) < i+1$ tengo que llegar a $d(t) < d'(t)$
    \item [6)] Caso 2, $d(x_{i+1}) = i+1$.
\end{itemize}

%%%%%% 6 %%%%%%
\begin{itemize}
    \item [6)] \textbf{Si $f$ es flujo las siguientes son equivalentes:
    \begin{itemize}
        \item [1.] $\exists S$ corte: $v(f) = cap(S)$
        \item [2.] $f$ es maximal.\\
        $(1=2)$ dice: \\
        "$f$ maximal $\Longleftrightarrow \exists S$ corte $v(f) = cap(S)$"\\
        y se suele llamar 'max-flow-min-cut theorem'.
        \item [3.] $\nexists f-$caminos aumentanes entre $s$ y $t$\\
        y si se cumplen, el $s$ es minimal.
    \end{itemize}}
\end{itemize}

Definir y demostrar en ese orden.
\begin{itemize}
    \item Si $f$ es flujo las siguientes son equivalentes:
    \begin{itemize}
        \item [1.] $\exists S$ corte: $v(f) = cap(S)$
        \item [2.] $f$ es maximal.\\
        $(1=2)$ dice: \\
        "$f$ maximal $\Longleftrightarrow \exists S$ corte $v(f) = cap(S)$"\\
        y se suele llamar 'max-flow-min-cut theorem'.
        \item [3.] $\nexists f-$caminos aumentanes entre $s$ y $t$\\
        y si se cumplen, el $s$ es minimal.
    \end{itemize}
\end{itemize}

La prueba es $1) \Rightarrow 2) \Rightarrow 3) \Rightarrow 1)$.
\medskip

$1) \Rightarrow 2)$ es fácil. $2) \Rightarrow 3)$ se hace por contrareciproca.
\medskip

$3) \Rightarrow 1)$ es la parte más difícil. 
\begin{itemize}
    \item [1)] Definir $S = \llaves{s} \cup \llaves{x: \exists\,\, \text{un $f-$ca de $s$ a $x$}}$.
    \item [2)] Como $f$ es flujo y $S$ corte, entonces $v(f) = f(S,\overline{S}) - f(\overline{S},S)$. 
        entonces $f(S,\overline{S}) = \sum_{x\in S, y\in \overline{S}, xy\in E} f(\overrightarrow{xy})$.
    \item [3)] Tomar un par $(x,y)$ cualquiera $x\in S, y\notin S, xy\in E$ entonces 
        existe un ca entre $s\ldots x$
    \item [4)] suponfamos que $f(\overrightarrow{xy}) < c(\overrightarrow{xy})$ 
        no se satura. se llega a un absurdo $y \in S$
    \item [5)] Ahora lado backward $f(\overline{S},S) = \sum_{x\notin S, y\in S, xy\in E} f(\overrightarrow{xy})$.
    \item [6)] Se toma un par cualquiera $(x,y)$ mismo analisis que en el paso 3.
        pero para backward, ahora el absurdo es $x\in S$. 
\end{itemize}

%%%%%% 7 %%%%%%
\begin{itemize}
    \item [7)] \textbf{Probar que $2-$COLOR es polinomial.}
    \label{dem:2color}
\end{itemize}

%%%%%% 8 %%%%%%
\begin{itemize}
    \item [8)] \textbf{Enunciar y probar el Teorema de Hall.}
    \label{dem:hall}
\end{itemize}

\begin{teorema} (Hall) Si $G = (\bar{X} \cup \bar{Y}, E)$ es bipartito con partes 
    $\bar{X}$ e $\bar{Y}$, entonces existe matching completo de $\bar{X}$ en $\bar{Y}$
    si y solo si $|S| \< |\Gamma(S)| \,\, \forall S \subseteq \bar{X}$.
\end{teorema}
\begin{itemize}
    \item [1)] $\Rightarrow$ Definir la función inyectiva  $\bar{X} \cap \bar{Y}$
        tal que $\psi(x) \in E$, por lo tanto: $$\psi(S) \subseteq \Gamma(S)$$
    \item [2)] $\Leftarrow$ Se demuestra por contrareciproc, es decir que si no 
        existe matching completo de $\bar{X}$ en $\bar{Y}$ entonces al correr el 
        algoritmo llegamos a un matching maximal que no cubre a $\bar{X}$. Que es 
        equivalente a hallar un flujo maximal entero $f$ cuyo valor no es $|\bar{X}|$.
    \item [3)] Al hallar $f$, tambien hallamos un corte minimal que vamos a denotar 
        por $c$ (seria la última cola, al correr EK).
    \item [4)] Sea $S = c\cap \bar{X}$, $T = c\cap \bar{Y}$, $T$ forma parte de $c$ 
        por lo tanto forma parte de la última cola, entonces todos sus elmeentos 
        fueron agregados por alguien (pues $S \notin T$), ese alguien debe ser vecino 
        y como el grafo es bipartito y $T \subseteq \bar{Y}$, esos vecnios deben 
        estar en $\bar{X}$. Pero ademas deben haber estado en la cola, es decir, 
        que están en $c$. Entonces el vecino estaba en $S$. Gracias a esto 
        $T \subseteq \Gamma(S)$ y $\Gamma(S) \subseteq T$. 
    \item [5)] Hay que probar estas influciones
    \item [6)] $\Gamma(S) \subseteq T$. Sea $y \in \Gamma(S)$, entonces 
        $\exists x \in S: xy \in E$ ($x$ esta en la cola).
        Supones que $f(\overrightarrow{xy}) = 0$ entonces $xy \in c$ y $y \in T$.
        Supones que $f(\overrightarrow{xy}) = 1$ entonces $x$ no puede agregar a $y$ 
        a la cola pero $x \in S$, entonces algun vertice $z$ agrego a $x$ a la cola.
        Seguir en base a esto
\end{itemize}

%%%%%% 9 %%%%%%
\begin{itemize}
    \item [9)] \textbf{Enunciar y probar el teorema del matrimonio de Konig}
    \label{dem:konig}
\end{itemize}

\begin{teorema} (matrimonio de konig) Todo grafo bipartito regular tiene un matching 
    perfecto (todos los vertices dorman parte del matching).
\end{teorema}
\begin{itemize}
    \item [1)] Se parte dado un conjunto de vertices definiendo $E_{w} = \llaves{zw\in E : z\in W}$.
    \item [2)] Sean $\bar{X}$ y $\bar{Y}$ las partes de $G$ y suponemos $w \subseteq \bar{Y}$
        (completamente contenido en $\bar{X}$). 
\end{itemize}
%%%%%% 10 %%%%%%
\begin{itemize}
    \item [10)] \textbf{Probar que si $G$ es bipartito entonces $\chi^{'}(G) = \Delta(G)$}
    \label{dem:chi}
\end{itemize}

%%%%%% 11 %%%%%%
\begin{itemize}
    \item [11)] \textbf{Probar la complejidad $O(n^{4})$ del algoritmo Hungaro y dar una idea 
    de como se la puede reducir a $O(n^{3})$.}
    \label{dem:hungaro}
\end{itemize}


%%%%%% 12 %%%%%%
\begin{itemize}
    \item [12)] \textbf{Enunciar el teorema de la cota de Hamming y probarlo}
    \label{dem:hamming}
\end{itemize}

%%%%%% 13 %%%%%%
\begin{itemize}
    \item [13)] \textbf{Probar que si $H$ es matriz de chequeo de $C$, entonces
        $$\delta(C) = \min {j: \exists \,\,\text{un conjunto de $j$ columnas LD de $H$}}$$
        (LD es linealmente dependiente)}
    \label{dem:delta}
\end{itemize}

%%%%%% 14 %%%%%%
\begin{itemize} 
    \item [14)]\textbf{(Fundamental de código ciclico) Sea $C$ un código ciclico de 
    longitud $n$ con generador $g(x)$ entonces:
    \begin{itemize}
        \item [1)] $C = \llaves{p(x)\in \mathbb{Z}_{2}(x):gr(p)<n \wedge g(x)|p(x)}$ por esto 
            se dice que $C$ es generador (son los multiplicos de $g(x)$ de menor grado).
        \item [2)] $C = \llaves{v(x)\odot g(x): v\in \mathbb{Z}_{2}(x)}$ son los multiplos 
            de $g$ modulares.
        \item [3)] Si $k=Dim(C)$ entonces $gr(g)=n-k$.
        \item [4)] $g(x) | (1+x^{n})$.
        \item [5)] Si $g(x) = g_{0} + g_{1}x + \ldots +$ entonces $g_{0}=1$.
    \end{itemize}}
\end{itemize}

%%%%%% 15 %%%%%%
\begin{itemize}
    \item [15)] \textbf{Probar que $3$SAT es NP-completo}
    \label{dem:3sat}
\end{itemize}


%%%%%% 16 %%%%%%
\begin{itemize}
    \item [16)] \textbf{Probar que $3-$COLOR es NP-completo}
    \label{dem:3color}
\end{itemize}

\end{document}